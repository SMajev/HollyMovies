"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const got_1 = __importDefault(require("got"));
const stream_1 = __importDefault(require("stream"));
const fs_1 = require("fs");
const util_1 = require("util");
const path_1 = require("path");
const d_fi_core_1 = require("d-fi-core");
const log_update_1 = __importDefault(require("log-update"));
const chalk_1 = __importDefault(require("chalk"));
const signale_1 = __importDefault(require("../lib/signale"));
const util_2 = require("./util");
const get_url_1 = require("d-fi-core/dist/lib/get-url");
const pipeline = (0, util_1.promisify)(stream_1.default.pipeline);
const simulate = process.env.SIMULATE;
const downloadTrack = async ({ track, quality, info, coverSizes, path, totalTracks, trackNumber = true, fallbackTrack = true, fallbackQuality = true, isFallback = false, isQualityFallback = false, message = '', }) => {
    (0, log_update_1.default)(signale_1.default.pending(track.SNG_TITLE + ' by ' + track.ART_NAME + ' from ' + track.ALB_TITLE));
    try {
        let ext = '.mp3', fileSize = 0, downloaded = 0, coverSize = 500;
        switch (quality) {
            case 1:
            case '1':
            case '128':
            case 'MP3_128':
            case '128kbps':
                quality = 1;
                fileSize = Number(track.FILESIZE_MP3_128);
                coverSize = coverSizes['128'];
                break;
            case 9:
            case '9':
            case 'flac':
            case 'Flac':
            case 'FLAC':
                quality = 9;
                ext = '.flac';
                fileSize = Number(track.FILESIZE_FLAC);
                coverSize = coverSizes['flac'];
                break;
            default:
                quality = 3;
                fileSize = Number(track.FILESIZE_MP3_320);
                coverSize = coverSizes['320'];
        }
        const savePath = (0, util_2.saveLayout)({ track, album: info, path, trackNumber, minimumIntegerDigits: totalTracks >= 100 ? 3 : 2 }) + ext;
        if ((0, fs_1.existsSync)(savePath)) {
            (0, log_update_1.default)(signale_1.default.info(`Skipped "${track.SNG_TITLE}", track already exists.`));
            log_update_1.default.done();
            (0, log_update_1.default)(signale_1.default.note(savePath));
            log_update_1.default.done();
            return savePath;
        }
        let trackData;
        try {
            trackData = await (0, d_fi_core_1.getTrackDownloadUrl)(track, quality);
        }
        catch (err) {
            if (!(err instanceof get_url_1.GeoBlocked) || !track.FALLBACK) {
                throw err;
            }
        }
        if (!trackData) {
            if (fallbackTrack && track.FALLBACK && !isFallback && track.ART_ID === track.FALLBACK.ART_ID) {
                const { FALLBACK, ...CURRENT_TRACK } = track;
                return await downloadTrack({
                    track: { ...CURRENT_TRACK, ...FALLBACK },
                    quality,
                    info,
                    coverSizes,
                    path,
                    totalTracks,
                    trackNumber,
                    fallbackTrack: false,
                    isFallback: true,
                    message,
                });
            }
            else if (fallbackQuality && quality !== 1) {
                return await downloadTrack({
                    track,
                    quality: quality === 9 ? 3 : 1,
                    info,
                    coverSizes,
                    path,
                    totalTracks,
                    trackNumber,
                    fallbackTrack,
                    isFallback,
                    isQualityFallback: true,
                    message,
                });
            }
            (0, log_update_1.default)(signale_1.default.warn(`Skipped "${track.SNG_TITLE}", track not available.`));
            log_update_1.default.done();
            return;
        }
        const headers = {};
        const tmpfile = `d-fi_${quality}_${track.SNG_ID}_${simulate ? 'simulate' : track.MD5_ORIGIN}`;
        if (simulate) {
            coverSize = 56;
            headers.range = 'bytes=0-1023';
        }
        else if ((0, fs_1.existsSync)(tmpfile)) {
            const tmpfilestat = (0, fs_1.statSync)(tmpfile);
            downloaded = tmpfilestat.size;
            headers.range = 'bytes=' + tmpfilestat.size + '-';
        }
        fileSize = trackData.fileSize;
        const bar = (0, util_2.progressBar)(fileSize, 40);
        const humanSizeTotal = (fileSize / 1024 / 1024).toFixed(2);
        let transferredLast = downloaded;
        await pipeline(got_1.default.stream(trackData.trackUrl, { responseType: 'buffer', headers }).on('downloadProgress', ({ transferred }) => {
            // Report download progress
            transferred += downloaded;
            if (transferred - transferredLast > 50000) {
                transferredLast = transferred;
                (0, log_update_1.default)(signale_1.default.info(`Downloading ${track.SNG_TITLE} ${message}\n  ${bar(transferred)} | ${humanSizeTotal}MiB`));
            }
        }), (0, fs_1.createWriteStream)(tmpfile, { flags: 'a', autoClose: true }));
        let outFile;
        if (trackData.isEncrypted) {
            (0, log_update_1.default)(signale_1.default.pending('Decrypting ' + track.SNG_TITLE + ' by ' + track.ART_NAME));
            outFile = (0, d_fi_core_1.decryptDownload)((0, fs_1.readFileSync)(tmpfile), track.SNG_ID);
        }
        else {
            outFile = (0, fs_1.readFileSync)(tmpfile);
        }
        (0, log_update_1.default)(signale_1.default.pending('Tagging ' + track.SNG_TITLE + ' by ' + track.ART_NAME));
        const trackWithMetadata = await (0, d_fi_core_1.addTrackTags)(outFile, track, coverSize);
        // Delete temporary file now
        (0, fs_1.unlinkSync)(tmpfile);
        (0, log_update_1.default)(signale_1.default.pending('Saving ' + track.SNG_TITLE + ' by ' + track.ART_NAME));
        if (!simulate) {
            // Create directory if not exists
            const dir = (0, path_1.dirname)(savePath);
            if (!(0, fs_1.existsSync)(dir)) {
                (0, fs_1.mkdirSync)(dir, { recursive: true });
            }
            // Save file to disk
            (0, fs_1.writeFileSync)(savePath, trackWithMetadata);
        }
        // Print sucess info
        (0, log_update_1.default)(signale_1.default.success(`${isFallback ? chalk_1.default.yellow('[Fallback] ') : ''}${track.SNG_TITLE} by ${track.ART_NAME}`));
        log_update_1.default.done();
        if (isQualityFallback) {
            (0, log_update_1.default)(signale_1.default.note(`Used ${quality === 3 ? '320kbps' : '128kbps'} as other formats were unavailable`));
            log_update_1.default.done();
        }
        return savePath;
    }
    catch (err) {
        (0, log_update_1.default)(signale_1.default.error(track.SNG_TITLE));
        log_update_1.default.done();
        (0, log_update_1.default)(signale_1.default.note(err.message));
        log_update_1.default.done();
    }
};
exports.default = downloadTrack;
